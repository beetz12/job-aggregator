#!/usr/bin/env python3
"""
BTR ROI Calculator

This script calculates detailed Return on Investment (ROI) metrics for your
BTR context library. It analyzes usage patterns and provides insights
on the value generated by your curated knowledge base.

Usage:
    python calculate-roi.py
    python calculate-roi.py --hourly-rate 150
    python calculate-roi.py --format markdown
    python calculate-roi.py --stats-file /path/to/stats.json
"""

import argparse
import json
import os
import sys
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

# Default configuration
DEFAULT_HOURLY_RATE = 100  # USD per hour
DEFAULT_AVG_MANUAL_SEARCH_TIME = 15  # minutes
DEFAULT_AVG_CURATION_TIME = 10  # minutes per context
DEFAULT_CONTEXT_MAINTENANCE_TIME = 5  # minutes per month per context


@dataclass
class ContextStats:
    """Statistics for a single context."""
    domain: str
    topic: str
    retrievals: int
    created_at: str
    last_accessed: Optional[str]
    tags: List[str]


@dataclass
class DomainStats:
    """Aggregated statistics for a domain."""
    name: str
    context_count: int
    total_retrievals: int
    avg_retrievals_per_context: float


@dataclass
class ROIMetrics:
    """Calculated ROI metrics."""
    total_contexts: int
    total_domains: int
    total_retrievals: int

    # Time metrics
    time_saved_hours: float
    time_invested_hours: float
    net_time_saved_hours: float

    # Value metrics
    value_generated_usd: float
    cost_invested_usd: float
    net_value_usd: float
    roi_percentage: float

    # Efficiency metrics
    avg_retrievals_per_context: float
    most_valuable_contexts: List[Tuple[str, int, float]]
    least_used_contexts: List[Tuple[str, int]]

    # Projections
    monthly_value_trend: float
    annual_projected_value: float


def load_stats(stats_file: Optional[str] = None) -> Dict:
    """Load statistics from file or generate sample data."""
    if stats_file and os.path.exists(stats_file):
        with open(stats_file, 'r') as f:
            return json.load(f)

    # Generate sample statistics for demonstration
    return {
        'total_contexts': 42,
        'total_domains': 8,
        'total_retrievals': 156,
        'contexts': [
            {'domain': 'auth', 'topic': 'jwt-validation', 'retrievals': 23, 'created_at': '2024-01-15', 'last_accessed': '2024-03-10', 'tags': ['jwt', 'security']},
            {'domain': 'api', 'topic': 'rate-limiting', 'retrievals': 18, 'created_at': '2024-01-20', 'last_accessed': '2024-03-09', 'tags': ['api', 'security']},
            {'domain': 'database', 'topic': 'connection-pooling', 'retrievals': 15, 'created_at': '2024-02-01', 'last_accessed': '2024-03-08', 'tags': ['postgresql', 'performance']},
            {'domain': 'auth', 'topic': 'oauth-google', 'retrievals': 12, 'created_at': '2024-01-25', 'last_accessed': '2024-03-07', 'tags': ['oauth', 'google']},
            {'domain': 'frontend', 'topic': 'form-validation', 'retrievals': 11, 'created_at': '2024-02-05', 'last_accessed': '2024-03-06', 'tags': ['react', 'validation']},
            {'domain': 'testing', 'topic': 'mock-api-patterns', 'retrievals': 10, 'created_at': '2024-02-10', 'last_accessed': '2024-03-05', 'tags': ['testing', 'msw']},
            {'domain': 'devops', 'topic': 'docker-compose-dev', 'retrievals': 9, 'created_at': '2024-02-15', 'last_accessed': '2024-03-04', 'tags': ['docker', 'development']},
            {'domain': 'architecture', 'topic': 'error-handling-strategy', 'retrievals': 8, 'created_at': '2024-02-20', 'last_accessed': '2024-03-03', 'tags': ['patterns', 'errors']},
        ],
        'domains': [
            {'name': 'auth', 'context_count': 12, 'total_retrievals': 45},
            {'name': 'api', 'context_count': 10, 'total_retrievals': 38},
            {'name': 'database', 'context_count': 8, 'total_retrievals': 29},
            {'name': 'frontend', 'context_count': 5, 'total_retrievals': 22},
            {'name': 'testing', 'context_count': 3, 'total_retrievals': 12},
            {'name': 'devops', 'context_count': 2, 'total_retrievals': 6},
            {'name': 'architecture', 'context_count': 1, 'total_retrievals': 3},
            {'name': 'security', 'context_count': 1, 'total_retrievals': 1},
        ],
        'period_start': '2024-01-01',
        'period_end': '2024-03-10',
    }


def calculate_roi(
    stats: Dict,
    hourly_rate: float = DEFAULT_HOURLY_RATE,
    avg_manual_search_time: int = DEFAULT_AVG_MANUAL_SEARCH_TIME,
    avg_curation_time: int = DEFAULT_AVG_CURATION_TIME,
) -> ROIMetrics:
    """Calculate detailed ROI metrics from statistics."""

    total_contexts = stats.get('total_contexts', 0)
    total_retrievals = stats.get('total_retrievals', 0)
    total_domains = stats.get('total_domains', 0)
    contexts = stats.get('contexts', [])

    # Time calculations
    time_saved_minutes = total_retrievals * avg_manual_search_time
    time_saved_hours = time_saved_minutes / 60

    time_invested_minutes = total_contexts * avg_curation_time
    time_invested_hours = time_invested_minutes / 60

    net_time_saved_hours = time_saved_hours - time_invested_hours

    # Value calculations
    value_generated = time_saved_hours * hourly_rate
    cost_invested = time_invested_hours * hourly_rate
    net_value = value_generated - cost_invested

    roi_percentage = ((value_generated - cost_invested) / cost_invested * 100) if cost_invested > 0 else 0

    # Efficiency metrics
    avg_retrievals = total_retrievals / total_contexts if total_contexts > 0 else 0

    # Most valuable contexts (by retrievals * hourly rate)
    sorted_contexts = sorted(contexts, key=lambda x: x.get('retrievals', 0), reverse=True)
    most_valuable = [
        (f"{c['domain']}/{c['topic']}", c['retrievals'], c['retrievals'] * avg_manual_search_time / 60 * hourly_rate)
        for c in sorted_contexts[:5]
    ]

    # Least used contexts
    least_used = [
        (f"{c['domain']}/{c['topic']}", c['retrievals'])
        for c in sorted_contexts[-5:]
    ]
    least_used.reverse()

    # Projections (simple linear projection)
    # Calculate days in period
    try:
        period_start = datetime.strptime(stats.get('period_start', '2024-01-01'), '%Y-%m-%d')
        period_end = datetime.strptime(stats.get('period_end', datetime.now().strftime('%Y-%m-%d')), '%Y-%m-%d')
        days_in_period = (period_end - period_start).days or 1
    except ValueError:
        days_in_period = 30

    daily_value = net_value / days_in_period if days_in_period > 0 else 0
    monthly_value_trend = daily_value * 30
    annual_projected_value = daily_value * 365

    return ROIMetrics(
        total_contexts=total_contexts,
        total_domains=total_domains,
        total_retrievals=total_retrievals,
        time_saved_hours=round(time_saved_hours, 1),
        time_invested_hours=round(time_invested_hours, 1),
        net_time_saved_hours=round(net_time_saved_hours, 1),
        value_generated_usd=round(value_generated, 2),
        cost_invested_usd=round(cost_invested, 2),
        net_value_usd=round(net_value, 2),
        roi_percentage=round(roi_percentage, 1),
        avg_retrievals_per_context=round(avg_retrievals, 2),
        most_valuable_contexts=most_valuable,
        least_used_contexts=least_used,
        monthly_value_trend=round(monthly_value_trend, 2),
        annual_projected_value=round(annual_projected_value, 2),
    )


def format_as_text(metrics: ROIMetrics, hourly_rate: float) -> str:
    """Format ROI metrics as human-readable text."""
    lines = [
        "=" * 60,
        "BTR ROI ANALYSIS",
        "=" * 60,
        "",
        "OVERVIEW",
        "-" * 40,
        f"Total Contexts:      {metrics.total_contexts}",
        f"Total Domains:       {metrics.total_domains}",
        f"Total Retrievals:    {metrics.total_retrievals}",
        f"Avg Retrievals/Ctx:  {metrics.avg_retrievals_per_context}",
        "",
        "TIME ANALYSIS",
        "-" * 40,
        f"Time Saved:          {metrics.time_saved_hours} hours",
        f"Time Invested:       {metrics.time_invested_hours} hours",
        f"Net Time Saved:      {metrics.net_time_saved_hours} hours",
        "",
        f"VALUE ANALYSIS (@ ${hourly_rate}/hour)",
        "-" * 40,
        f"Value Generated:     ${metrics.value_generated_usd:,.2f}",
        f"Cost Invested:       ${metrics.cost_invested_usd:,.2f}",
        f"Net Value:           ${metrics.net_value_usd:,.2f}",
        f"ROI:                 {metrics.roi_percentage}%",
        "",
        "MOST VALUABLE CONTEXTS",
        "-" * 40,
    ]

    for i, (name, retrievals, value) in enumerate(metrics.most_valuable_contexts, 1):
        lines.append(f"  {i}. {name}")
        lines.append(f"     {retrievals} retrievals = ${value:,.2f} value")

    lines.extend([
        "",
        "CONTEXTS TO REVIEW (Low Usage)",
        "-" * 40,
    ])

    for name, retrievals in metrics.least_used_contexts:
        lines.append(f"  - {name} ({retrievals} retrievals)")

    lines.extend([
        "",
        "PROJECTIONS",
        "-" * 40,
        f"Monthly Value Trend: ${metrics.monthly_value_trend:,.2f}/month",
        f"Annual Projection:   ${metrics.annual_projected_value:,.2f}/year",
        "",
        "=" * 60,
    ])

    return "\n".join(lines)


def format_as_json(metrics: ROIMetrics) -> str:
    """Format ROI metrics as JSON."""
    return json.dumps({
        'overview': {
            'total_contexts': metrics.total_contexts,
            'total_domains': metrics.total_domains,
            'total_retrievals': metrics.total_retrievals,
            'avg_retrievals_per_context': metrics.avg_retrievals_per_context,
        },
        'time_analysis': {
            'time_saved_hours': metrics.time_saved_hours,
            'time_invested_hours': metrics.time_invested_hours,
            'net_time_saved_hours': metrics.net_time_saved_hours,
        },
        'value_analysis': {
            'value_generated_usd': metrics.value_generated_usd,
            'cost_invested_usd': metrics.cost_invested_usd,
            'net_value_usd': metrics.net_value_usd,
            'roi_percentage': metrics.roi_percentage,
        },
        'most_valuable_contexts': [
            {'path': name, 'retrievals': retrievals, 'value_usd': value}
            for name, retrievals, value in metrics.most_valuable_contexts
        ],
        'least_used_contexts': [
            {'path': name, 'retrievals': retrievals}
            for name, retrievals in metrics.least_used_contexts
        ],
        'projections': {
            'monthly_value_trend': metrics.monthly_value_trend,
            'annual_projected_value': metrics.annual_projected_value,
        },
    }, indent=2)


def format_as_markdown(metrics: ROIMetrics, hourly_rate: float) -> str:
    """Format ROI metrics as Markdown."""
    lines = [
        "# BTR ROI Analysis",
        "",
        "## Overview",
        "",
        "| Metric | Value |",
        "|--------|-------|",
        f"| Total Contexts | {metrics.total_contexts} |",
        f"| Total Domains | {metrics.total_domains} |",
        f"| Total Retrievals | {metrics.total_retrievals} |",
        f"| Avg Retrievals/Context | {metrics.avg_retrievals_per_context} |",
        "",
        "## Time Analysis",
        "",
        "| Metric | Hours |",
        "|--------|-------|",
        f"| Time Saved | {metrics.time_saved_hours} |",
        f"| Time Invested | {metrics.time_invested_hours} |",
        f"| **Net Time Saved** | **{metrics.net_time_saved_hours}** |",
        "",
        f"## Value Analysis (@ ${hourly_rate}/hour)",
        "",
        "| Metric | Amount |",
        "|--------|--------|",
        f"| Value Generated | ${metrics.value_generated_usd:,.2f} |",
        f"| Cost Invested | ${metrics.cost_invested_usd:,.2f} |",
        f"| **Net Value** | **${metrics.net_value_usd:,.2f}** |",
        f"| **ROI** | **{metrics.roi_percentage}%** |",
        "",
        "## Most Valuable Contexts",
        "",
        "| Rank | Context | Retrievals | Value |",
        "|------|---------|------------|-------|",
    ]

    for i, (name, retrievals, value) in enumerate(metrics.most_valuable_contexts, 1):
        lines.append(f"| {i} | `{name}` | {retrievals} | ${value:,.2f} |")

    lines.extend([
        "",
        "## Contexts to Review",
        "",
        "These contexts have low usage and may need updating or removal:",
        "",
    ])

    for name, retrievals in metrics.least_used_contexts:
        lines.append(f"- `{name}` ({retrievals} retrievals)")

    lines.extend([
        "",
        "## Projections",
        "",
        f"- **Monthly Value Trend:** ${metrics.monthly_value_trend:,.2f}/month",
        f"- **Annual Projection:** ${metrics.annual_projected_value:,.2f}/year",
    ])

    return "\n".join(lines)


def format_as_csv(metrics: ROIMetrics) -> str:
    """Format ROI metrics as CSV (single row for time series)."""
    headers = [
        'timestamp', 'total_contexts', 'total_domains', 'total_retrievals',
        'time_saved_hours', 'time_invested_hours', 'net_time_saved_hours',
        'value_generated_usd', 'cost_invested_usd', 'net_value_usd', 'roi_percentage'
    ]
    values = [
        datetime.now().isoformat(),
        str(metrics.total_contexts),
        str(metrics.total_domains),
        str(metrics.total_retrievals),
        str(metrics.time_saved_hours),
        str(metrics.time_invested_hours),
        str(metrics.net_time_saved_hours),
        str(metrics.value_generated_usd),
        str(metrics.cost_invested_usd),
        str(metrics.net_value_usd),
        str(metrics.roi_percentage),
    ]

    return ",".join(headers) + "\n" + ",".join(values)


def main():
    parser = argparse.ArgumentParser(
        description='Calculate ROI metrics for BTR context library'
    )
    parser.add_argument(
        '--hourly-rate',
        type=float,
        default=DEFAULT_HOURLY_RATE,
        help=f'Developer hourly rate in USD (default: ${DEFAULT_HOURLY_RATE})'
    )
    parser.add_argument(
        '--avg-time',
        type=int,
        default=DEFAULT_AVG_MANUAL_SEARCH_TIME,
        help=f'Average manual search time in minutes (default: {DEFAULT_AVG_MANUAL_SEARCH_TIME})'
    )
    parser.add_argument(
        '--stats-file',
        type=str,
        help='Path to stats JSON file (uses sample data if not provided)'
    )
    parser.add_argument(
        '--format',
        choices=['text', 'json', 'markdown', 'csv'],
        default='text',
        help='Output format (default: text)'
    )

    args = parser.parse_args()

    # Load statistics
    stats = load_stats(args.stats_file)

    # Calculate ROI
    metrics = calculate_roi(
        stats,
        hourly_rate=args.hourly_rate,
        avg_manual_search_time=args.avg_time,
    )

    # Output in requested format
    if args.format == 'json':
        print(format_as_json(metrics))
    elif args.format == 'markdown':
        print(format_as_markdown(metrics, args.hourly_rate))
    elif args.format == 'csv':
        print(format_as_csv(metrics))
    else:
        print(format_as_text(metrics, args.hourly_rate))


if __name__ == '__main__':
    main()
